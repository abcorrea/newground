%%%% ijcai22-multiauthor.tex

\typeout{IJCAI--22 Multiple authors example}

% These are the instructions for authors for IJCAI-22.

\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in
% The file ijcai22.sty is NOT the same as previous years'
\usepackage{ijcai22}

% Use the postscript times font!
\usepackage{times}
\renewcommand*\ttdefault{txtt}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{booktabs}
\urlstyle{same}
\bibliographystyle{named}

% the following package is optional:
%\usepackage{latexsym}

% Following comment is from ijcai97-submit.tex:
% The preparation of these files was supported by Schlumberger Palo Alto
% Research, AT\&T Bell Laboratories, and Morgan Kaufmann Publishers.
% Shirley Jowell, of Morgan Kaufmann Publishers, and Peter F.
% Patel-Schneider, of AT\&T Bell Laboratories collaborated on their
% preparation.

% These instructions can be modified and used in other conferences as long
% as credit to the authors and supporting agencies is retained, this notice
% is not changed, and further modification or reuse is not restricted.
% Neither Shirley Jowell nor Peter F. Patel-Schneider can be listed as
% contacts for providing assistance without their prior permission.

% To use for other conferences, change references to files and the
% conference appropriate and use other authors, contacts, publishers, and
% organizations.
% Also change the deadline and address for returning papers and the length and
% page charge instructions.
% Put where the files are available in the appropriate places.

%PDF Info Is REQUIRED.
% Please **do not** include Title and Author information
\pdfinfo{
/TemplateVersion (IJCAI.2022.0)
}


\title{Efficient Grounding via Solving: Is Searching for Rule Instantiations an Option?} %Alternative?}

\author{
Anonymous Submission
%First Author$^1$\footnote{Contact Author}\and
%Second Author$^2$\and
%Third Author$^{2,3}$\And
%Fourth Author$^4$\\
%\affiliations
%$^1$First Affiliation\\
%$^2$Second Affiliation\\
%$^3$Third Affiliation\\
%$^4$Fourth Affiliation\\
%\emails
%\{first, second\}@example.com,
%third@other.example.com,
%fourth@example.com
}

\begin{document}

\maketitle

\begin{abstract}
This short example shows a contrived example on how to format the authors' information for {\it IJCAI--22 Proceedings} using \LaTeX{}.
\end{abstract}

\section{Introduction}

Answer set programming (ASP)~\cite{BrewkaEiterTruszczynski11,GebserEtAl19,%,GebserKaminskiSchaub11,%GebserKaminskiKaufmannSchaub12,
JanhunenNiemela16a} is a modeling and solving framework
that can be seen as an extension of propositional satisfiability (SAT),
where knowledge is expressed by means of rules comprising a \emph{(logic) program}, whose solutions are sets of atoms, called \emph{answer sets}, that obey every rule.
%
%
%These programs comprise different rules, whose solutions are sets of facts (``\emph{answer sets}'') that obey these rules.
%
%Both aspects (i) and (ii) combined finally lead to ASP being successfully applied in academia as well as industry. %~\cite{GebserEtAl11}. 
%Logic
% that form a \emph{(logic) program}.
%
When considering logic programs as a target language, one might first
think of the fact that ASP enables modeling beyond logical implications (satisfiability).
%
Indeed, there is a built-in principle of ASP requiring that whenever some facts
hold, these have to be \emph{justified (founded)} accordingly. %justifications.
%
This principle might be familiar from constructive math
%Constructiveness due to Aspect (i) is 
%are
and it is 
tightly coupled with the ASP semantics,
%Constructiveness due to Aspect (i) is tightly coupled with the ASP semantics, 
allowing for 
%and resulted in language extensions for 
%simple and 
elegant modeling of real-world problems up to the third level
of the polynomial hierarchy, cf.~\cite{}. %, which is combined in the ASP-Core-2 standard~\cite{CalimeriEtAl20}.
%
Notably, there are known NP-complete fragments~\cite{}, like %deciding the consistency  if one restricts to only normal
\emph{normal programs} or \emph{tight programs}, but also the fragment of \emph{disjunctive programs}, whose consistency problem resides on the second level of the polynomial hierarchy~\cite{}.


However, there is also a second factor that 
increases the expressiveness of ASP over SAT, which is \emph{grounding}. % in regards of the following two aspects: %as
Interestingly, grounding kicks the complexity to NEXPTIME completeness~\cite{}
and is responsible for the so-called \emph{grounding bottleneck}~\cite{CuteriEtAl20,TsamouraEtAl20}.
%two-fold: 
%(i) ``\emph{justifications}'': basic rules are similar to logical implications, but ASP
%goes beyond plain implications by requiring that whenever some facts
%are claimed to 
%hold, these have to be justified accordingly; %justifications.
%(ii) ``\emph{grounding}'': 
Classically, the process of grounding precedes solving and 
enables the formalization of problems %can be formalized 
by means of non-ground rules (rule schemes) that use first-order like variables.
%
During grounding, these variable occurrences of predicates are efficiently instantiated,
thereby forming atoms and generating (plain) logic programs.
% thereby relying on %with the help of
%efficient instantiation of first-order like variables. 
%
%
%
%
%Constructiveness due to Aspect (i) is tightly coupled with the ASP semantics, yielding 
%and resulted in language extensions for 
%simple and 
%elegant modeling of real-world problems, which is combined in the ASP-Core-2 standard~\cite{CalimeriEtAl20}.
%
%
%The resulting language % standardized
%%full 
%%ASP-Core-2 
%%language 
%is efficiently supported by the two major solvers: clasp~\cite{GebserEtAl19} %GebserKaminskiKaufmannSchaub12} 
%and wasp~\cite{AlvianoEtAl19}.
%
%Aspect (ii) is not just restricted to 
Efficient grounding is an active field of research and requires powerful rule initialization procedures trying to 
evade the intractable evaluation of non-ground programs. % in general. 
The literature distinguishes many different approaches, %, which is an active field of research,
ranging from traditional simplification and instantiation tactics~\cite{GebserEtAl19,AlvianoEtAl19,KaminskiSchaub21} over
%structural techniques%new techniques using tree decompositions
%~\cite{BichlerMorakWoltran20,CalimeriPerriZangari19}, 
fruitful estimations~\cite{HippenLierler21} and lazy grounding~\cite{%BogaertsWeinzierl18,
BomansonJanhunenWeinzierl19,WeinzierlTaupeFriedrich20}. %care that modeling
%
%Both aspects (i) and (ii) combined finally lead to ASP being successfully applied in academia as well as industry. %~\cite{GebserEtAl11}. 
%
%constraint-programming extensions~\cite{} or ASP modulo theory~\cite{}.
%
Besides lazy grounding, there are further attempts to avoid the grounding bottleneck, %The literature distinguishes techniques to circumvent this bottleneck~\cite{CuteriEtAl20,TsamouraEtAl20}, like the aforementioned lazy grounding and 
like the usage of constraint-programming or ASP modulo theory extensions, e.g.,~\cite{BanbaraEtAl17,JanhunenEtAl17,CabalarEtAl20}, 
as well as methods based on graph invariants like treewidth~\cite{BichlerMorakWoltran20,CalimeriPerriZangari19,BliemEtAl20,Mitchell19}
and even machine-learning guided solutions~\cite{}. %,
%where grounding is guided along . %\cite{BliemEtAl20,BichlerMorakWoltran20,Mitchell19}%, there have been also alternative approaches in order to speed-up grounding,
%which are based on graph invariants like treewidth.
%Besides creative ideas to circumvent the grounding bottleneck~\cite{CuteriEtAl20,TsamouraEtAl20}, like the aforementioned lazy grounding and constraint-programming or ASP modulo theory extensions~\cite{BanbaraEtAl17,JanhunenEtAl17,CabalarEtAl20}, there have been also been structural approaches %~\cite{BliemEtAl20,BichlerMorakWoltran20,Mitchell19} 
%with the goal of speeding-up grounding. %alternative approaches in order to speed-up grounding,
%which are based on graph invariants like treewidth.
%
%Intuitively, these approaches split up rule schemes by utilizing structural dependencies
%in the form of tree decompositions.
%
%However, these approaches have been designed for decision problems, but also reach limits of practical applicability, e.g., in case of large unstructured parts. 

Driven by the observation that modern solvers and
its underlying SAT technology have been improving for many years~\cite{},
we are convinced that a novel approach of grounding should be  interleaved with solving. % as well. % pursuing.
%
In this work, we therefore address the question of grounding from a  %want to pursue a 
different perspective: Can we translate
non-ground programs to ground programs, where grounding is carried out via the efficient search procedure included in modern ASP solvers?
 % approach. % technique that 
%

\medskip%
\noindent\textbf{Contributions. }Our contributions are as follows.
\begin{enumerate}
	\item We present a novel reduction from tight (non-ground) logic programs to disjunctive programs that encodes grounding via
search: For every answer set candidate, we thereby search for non-ground rules that are not satisfied as well as atoms that are potentially unjustified (unfounded). We utilize the saturation technique~\cite{} and trade instantiation of rules for the harder disjunctive fragment. In contrast to traditional grounding approaches, our reduction allows us to decouple predicates occurring in the body of a rule, which might be particularly useful for larger bodies with a very dense structure.
%To the best of our knowledge, this is  the first reduction of this kind for grounding.
	\item Assuming bounded predicate arity, our reduction is polynomial; in theory, it is particularly useful for small artiy. We show
that in general the jump from normal (non-ground) programs to disjunctive programs cannot be avoided (unless $P=NP$). 
We discuss further properties of our approach. % and establish further that %cannot be significantly improved, so the increase of complexity is required
	%\item 
	Further, in the light of recent treewidth-based approaches, 
            we establish that the treewidth of our reduction cannot be significantly improved in case of bounded arity as well as domain size. % it turns out TODO
	\item Then, we extend this approach to normal, non-ground programs, where for ensuring justifiability we additionally 
encode the idea of orderings (level mappings) in our reduction. 
	\item Finally, we show a prototype that supports traditional grounding by our approach, where heavy parts of the program are translated using our reduction, thereby empowering the grounding process by decoupling body predicates. % prior to traditional grounding. given by our approach. 
Preliminary experiments indicate that this approach might be fruitful, especially when structure-based approaches are not applicable, 
and grounding size would be excessively large. We suggest that our approach could be part of intelligent grounding procedures for estimating and evaluating different strategies~\cite{}. % and evaluating their chances of success. %  for parts of the program that   nitial study
\end{enumerate}

\smallskip
\noindent\textbf{Related Work. }Compiling ASP to non-ground;
Complexity of consistency over different program fragments,
where the predicate arity is bounded~\cite{EiterFaberFink07}.
Treewidth-based complexity of bounded domain size~\cite{FichteHecherMeier21}

\clearpage

\bibliography{ijcai22-refs}

\end{document}

